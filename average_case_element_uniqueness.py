# -*- coding: utf-8 -*-
"""average_case_element_uniqueness.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iRkGKlRakjtj4pzgHmeLV_oFxqjpP6lk
"""

#Average-case analysis of Element Uniqueness example from Levitin's Chapter 2.
#Array of size n and each number is drawn randomly in the range [1..n] with replacement
#For example for n=8, we have an exemplary array a=[1,3,5,1,3,4,8,8]

import random

def uniq(a):
#returns the number of comparison performed for checking element uniqueness
  n = len(a)
  cnt = 0
  for i in range(n-1):
    for j in range(i+1,n):
      if a[i] == a[j]:
        return cnt+1      #found the first identical pair and quiting
      else:
        cnt = cnt+1       #keep searching

  return cnt #returns n*(n-1)/2 if all elements were found to be unique


n=10
nrun = 100000   #number of runs for finding the average via empirical analysis

total_comparisons = 0
for irun in range(nrun):
  a=[]
  for i in range(n):
    a.append(random.randint(1,n))
  total_comparisons = total_comparisons + uniq(a)

print(total_comparisons/nrun)

import math

#Number of permutations
def nPr(n,r):
    f = math.factorial
    return f(n) // f(n-r)

#initialize total_comparisons
total_comparisons = n*(n-1)/2 * math.factorial(n)
#we have n! cases for which we find all elements as unique, then each such search will
#perform n*(n-1)/2 comparisons


#Suppose b is the index of the first number (indices start from 1 in this analysis)
#Suppose b+k is the index of the second number 
#for example take the case of n=8, b=2, and k=4 
#below are three sample arrays for this case
# a = [5,2,4,4,3,2,6,8] 
# a = [5,2,6,4,3,2,6,8] 
# a = [5,8,4,4,3,8,6,8] 
#We have 8 numbers in the array 
#and the number in the 2nd position matches with that in the 6th position
#We cannot have any other 5 in the array because if we had any other then we would have had b=1 (not 2)
#Also, whichever number is in the 2nd position it cannot be present between index b and index b+k

for b in range(1,n):    #b is the index of the first number
  for k in range(1,n-b+1):   #b+k is the index of the second number 
    comparisons = n*(n-1)/2 - (n-b+1)*(n-b)/2 + k 
    cases = (nPr(n,b)*((n-b)**(k-1))*((n-b+1)**(n-b-k)))
    total_comparisons = total_comparisons + comparisons*cases

all_possible_cases = n**n
average_number_comparisons = total_comparisons / all_possible_cases
print(average_number_comparisons)

import numpy as np
r = np.zeros((4,4))  #create a matrix r that can be used to check for correctness/debugging purposes
n=4
a=[0]*n
for i1 in range(1,n+1):
  a[0]=i1    #pick i1 (integer-1) randomly and place it as the first element of a
  for i2 in range(1,n+1):
    a[1]=i2  #pick i2 (integer-2) randomly and place it as the second element of a
    for i3 in range(1,n+1):
      a[2]=i3  #pick i3 randomly and place as the third element
      for i4 in range(1,n+1):
        a[3]=i4  #pick i4 randomly and place as the fourth element

        #find the first pair of identical elements (if any)
        breaking = False
        for b in range(n-1):
          for b_plus_k in range(b+1,n):
            if a[b] == a[b_plus_k]:
              k = b_plus_k - b
              r[b,k] = r[b,k]+1    #one more case found for this b and b+k combination 
              breaking = True
              break
          if breaking:
            break
print(r)